/**
 * This Firestore Security Ruleset defines the access control model for the StreamShare application.
 *
 * Core Philosophy:
 * The rules enforce a strict user-ownership model. All data created by a user is considered private
 * and is only accessible by that user. Global application data, such as streaming service
 * information and subscription plans, is publicly readable but not writable by clients, ensuring
 * that this data can only be managed by trusted backend services or administrators.
 *
 * Data Structure:
 * The data is organized into two main categories:
 * 1. User-Private Data: Stored under `/users/{userId}`, with subcollections for preferences
 *    (`user_preferences`) and subscriptions (`user_subscriptions`). This structure ensures that
 *    all of a user's data is logically and securely grouped under their unique ID.
 * 2. Public Data: Stored in top-level collections like `/streaming_services` and `/subscription_plans`.
 *    This separation allows for efficient and secure public queries without exposing private user information.
 *
 * Key Security Decisions:
 * - User Isolation: A user can only ever read or write documents within their own data tree
 *   (i.e., paths starting with `/users/{request.auth.uid}`).
 * - No User Listing: It is not possible for any client to list all documents in the `/users` collection.
 * - Public Data is Read-Only: Clients can read all streaming service and subscription plan data, but all
 *   write operations (`create`, `update`, `delete`) are denied. This protects the integrity of core
 *   application data.
 * - Relational Integrity: On creation of user-specific documents (like a subscription), the rules
 *   mandate that the document's internal `userId` field must match the user's authenticated UID,
 *   enforcing data consistency. This `userId` field is then enforced as immutable on updates.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the document being operated on already exists.
     * CRITICAL for preventing writes to non-existent documents on update/delete.
     */
    function isExistingDocument() {
      return resource != null;
    }

    /**
     * @description Rules for a user's own profile document.
     * @path /users/{userId}
     * @allow (create) A new user creating their own profile: `request.auth.uid == 'user_abc'` attempts to create `/users/user_abc`.
     * @deny (get) A user trying to read another user's profile: `request.auth.uid == 'user_abc'` attempts to get `/users/user_xyz`.
     * @deny (list) Any user trying to list all users in the system.
     * @principle Restricts access to a user's own data tree and enforces relational integrity on create.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && isExistingDocument() && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(userId) && isExistingDocument();
    }

    /**
     * @description Rules for a user's preference document, stored in a subcollection.
     * @path /users/{userId}/user_preferences/{preferenceId}
     * @allow (get) A user reading their own preferences: `request.auth.uid == 'user_abc'` attempts to get `/users/user_abc/user_preferences/profile`.
     * @deny (update) A user trying to modify another user's preferences: `request.auth.uid == 'user_abc'` attempts to update `/users/user_xyz/user_preferences/profile`.
     * @principle Enforces document ownership via path and validates denormalized 'userId' for data consistency.
     */
    match /users/{userId}/user_preferences/{preferenceId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isOwner(userId) && isExistingDocument() && request.resource.data.userId == resource.data.id;
      allow delete: if isOwner(userId) && isExistingDocument();
    }

    /**
     * @description Rules for a user's subscription records.
     * @path /users/{userId}/user_subscriptions/{userSubscriptionId}
     * @allow (list) A user listing all of their own subscriptions: `request.auth.uid == 'user_abc'` lists `/users/user_abc/user_subscriptions`.
     * @deny (create) A user trying to create a subscription for another user: `request.auth.uid == 'user_abc'` attempts to create in `/users/user_xyz/user_subscriptions`.
     * @principle Enforces document ownership via path and validates denormalized 'userId' for data consistency.
     */
    match /users/{userId}/user_subscriptions/{userSubscriptionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isOwner(userId) && isExistingDocument() && request.resource.data.userId == resource.data.id;
      allow delete: if isOwner(userId) && isExistingDocument();
    }

    /**
     * @description Publicly readable information about streaming services.
     * @path /streaming_services/{serviceId}
     * @allow (get) Any user, signed in or not, can read a service's details.
     * @deny (create, update, delete) Any client attempting to modify service data. This must be done by a backend service.
     * @principle Segregates public read-only data from private user data.
     */
    match /streaming_services/{serviceId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Publicly readable information about subscription plans.
     * @path /subscription_plans/{planId}
     * @allow (list) Any user, signed in or not, can list all available plans.
     * @deny (create, update, delete) Any client attempting to modify plan data. This must be done by a backend service.
     * @principle Segregates public read-only data from private user data.
     */
    match /subscription_plans/{planId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}