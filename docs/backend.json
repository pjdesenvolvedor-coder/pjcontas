{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user account in the StreamShare application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "email": {
          "type": "string",
          "description": "The user's email address, used for communication and as a unique identifier (alongside the external authentication system).",
          "format": "email"
        },
        "firstName": {
          "type": "string",
          "description": "The user's first name."
        },
        "lastName": {
          "type": "string",
          "description": "The user's last name."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the user account was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the user account was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "email",
        "createdAt",
        "updatedAt"
      ]
    },
    "StreamingService": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StreamingService",
      "type": "object",
      "description": "Represents a streaming service provider like Netflix, Disney+, or HBO.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the StreamingService entity."
        },
        "name": {
          "type": "string",
          "description": "The common name of the streaming service (e.g., 'Netflix', 'Disney+')."
        },
        "description": {
          "type": "string",
          "description": "A brief description of the streaming service."
        },
        "logoUrl": {
          "type": "string",
          "description": "URL to the streaming service's logo image.",
          "format": "uri"
        },
        "websiteUrl": {
          "type": "string",
          "description": "The official website URL for the streaming service.",
          "format": "uri"
        },
        "isAvailable": {
          "type": "boolean",
          "description": "Indicates if the streaming service is currently offered through StreamShare."
        }
      },
      "required": [
        "id",
        "name",
        "description",
        "isAvailable"
      ]
    },
    "SubscriptionPlan": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SubscriptionPlan",
      "type": "object",
      "description": "Represents a specific subscription plan offered by a StreamingService.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the SubscriptionPlan entity."
        },
        "serviceId": {
          "type": "string",
          "description": "Reference to the StreamingService this plan belongs to. (Relationship: StreamingService 1:N SubscriptionPlan)"
        },
        "name": {
          "type": "string",
          "description": "The name of the subscription plan (e.g., 'Basic', 'Standard', 'Premium')."
        },
        "price": {
          "type": "number",
          "description": "The monthly price of the subscription plan."
        },
        "currency": {
          "type": "string",
          "description": "The currency in which the price is denominated (e.g., 'USD', 'BRL')."
        },
        "resolution": {
          "type": "string",
          "description": "The maximum video resolution offered by this plan (e.g., 'SD', 'HD', '4K')."
        },
        "maxUsers": {
          "type": "number",
          "description": "The maximum number of distinct user profiles allowed on this plan."
        },
        "concurrentStreams": {
          "type": "number",
          "description": "The maximum number of simultaneous streams allowed on this plan."
        },
        "features": {
          "type": "array",
          "description": "A list of key features included in this plan (e.g., 'Download content', 'Ad-free viewing').",
          "items": {
            "type": "string"
          }
        },
        "durationMonths": {
          "type": "number",
          "description": "The billing cycle duration in months (e.g., 1 for monthly, 12 for annual)."
        },
        "isActive": {
          "type": "boolean",
          "description": "Indicates if this subscription plan is currently available for purchase."
        }
      },
      "required": [
        "id",
        "serviceId",
        "name",
        "price",
        "currency",
        "isActive"
      ]
    },
    "UserSubscription": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserSubscription",
      "type": "object",
      "description": "Records a specific user's subscription to a particular plan, including its status and dates.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the UserSubscription entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User who owns this subscription. (Relationship: User 1:N UserSubscription)"
        },
        "planId": {
          "type": "string",
          "description": "Reference to the SubscriptionPlan that the user is subscribed to. (Relationship: SubscriptionPlan 1:N UserSubscription)"
        },
        "startDate": {
          "type": "string",
          "description": "The date when the subscription became active.",
          "format": "date-time"
        },
        "endDate": {
          "type": "string",
          "description": "The date when the subscription is set to expire or was cancelled.",
          "format": "date-time"
        },
        "status": {
          "type": "string",
          "description": "The current status of the subscription (e.g., 'active', 'cancelled', 'expired', 'pending_payment')."
        },
        "paymentReferenceId": {
          "type": "string",
          "description": "A reference ID from the external payment gateway for this subscription's transaction."
        },
        "subscribedPrice": {
          "type": "number",
          "description": "The price at which the user initially subscribed, in case plan prices change over time."
        },
        "nextBillingDate": {
          "type": "string",
          "description": "The next scheduled date for billing this recurring subscription.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "planId",
        "startDate",
        "status",
        "paymentReferenceId",
        "subscribedPrice"
      ]
    },
    "UserPreference": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserPreference",
      "type": "object",
      "description": "Stores user preferences and data points for the AI-powered subscription recommendation engine.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the UserPreference entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User whose preferences are stored. (Relationship: User 1:1 UserPreference)"
        },
        "genrePreferences": {
          "type": "array",
          "description": "A list of preferred content genres (e.g., 'Action', 'Comedy', 'Sci-Fi').",
          "items": {
            "type": "string"
          }
        },
        "contentQualityPreference": {
          "type": "string",
          "description": "User's preference for content quality (e.g., 'SD', 'HD', '4K')."
        },
        "preferredPriceRangeMin": {
          "type": "number",
          "description": "The minimum preferred monthly price for subscriptions."
        },
        "preferredPriceRangeMax": {
          "type": "number",
          "description": "The maximum preferred monthly price for subscriptions."
        },
        "preferredUserLimit": {
          "type": "number",
          "description": "The preferred minimum number of users supported by a subscription plan."
        },
        "explicitLikedServices": {
          "type": "array",
          "description": "References to StreamingServices explicitly indicated as liked by the user. (Relationship: StreamingService N:N UserPreference)",
          "items": {
            "type": "string"
          }
        },
        "explicitDislikedServices": {
          "type": "array",
          "description": "References to StreamingServices explicitly indicated as disliked by the user. (Relationship: StreamingService N:N UserPreference)",
          "items": {
            "type": "string"
          }
        },
        "lastUpdated": {
          "type": "string",
          "description": "Timestamp when the user preferences were last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "lastUpdated"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores individual user profiles. Access is restricted to the user identified by `userId` in the path, which must match `request.auth.uid`."
        }
      },
      {
        "path": "/users/{userId}/user_preferences/profile",
        "definition": {
          "entityName": "UserPreference",
          "schema": {
            "$ref": "#/backend/entities/UserPreference"
          },
          "description": "Stores a single document containing preferences for the user identified by `userId`. Access is restricted to the user themselves. The fixed document ID 'profile' ensures a 1:1 relationship. Includes denormalized 'userId' field (also in path) for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique ID of the user, matching `request.auth.uid`."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/user_subscriptions/{userSubscriptionId}",
        "definition": {
          "entityName": "UserSubscription",
          "schema": {
            "$ref": "#/backend/entities/UserSubscription"
          },
          "description": "Records a specific user's active or past subscriptions to various plans. Access is restricted to the user identified by `userId`. Includes denormalized 'userId' field (also in path) for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique ID of the user, matching `request.auth.uid`."
            },
            {
              "name": "userSubscriptionId",
              "description": "The unique ID of the user's specific subscription record."
            }
          ]
        }
      },
      {
        "path": "/streaming_services/{serviceId}",
        "definition": {
          "entityName": "StreamingService",
          "schema": {
            "$ref": "#/backend/entities/StreamingService"
          },
          "description": "Contains publicly available information about streaming service providers. Read access is granted to all users (authenticated and unauthenticated). Write access would typically be restricted to administrators or backend services.",
          "params": [
            {
              "name": "serviceId",
              "description": "The unique ID of the streaming service."
            }
          ]
        }
      },
      {
        "path": "/subscription_plans/{planId}",
        "definition": {
          "entityName": "SubscriptionPlan",
          "schema": {
            "$ref": "#/backend/entities/SubscriptionPlan"
          },
          "description": "Contains publicly available details of all subscription plans offered by various streaming services. This is a top-level collection for efficient global querying. Read access is granted to all users. Includes 'serviceId' for linking to a specific StreamingService.",
          "params": [
            {
              "name": "planId",
              "description": "The unique ID of the subscription plan."
            }
          ]
        }
      }
    ],
    "reasoning": "The recommended Firestore structure prioritizes robust security rules, scalability, and debuggability by adhering to the core design principles. \n\n**Authorization Independence via Denormalization:** This design eliminates the need for `get()` calls in Firestore Security Rules, which is critical for performance and atomic operations. For user-specific data such as `UserSubscription` and `UserPreference`, the `userId` is embedded directly into the path (`/users/{userId}/...`). This means authorization rules can directly compare `request.auth.uid` with the `{userId}` wildcard in the path, ensuring that users can only access their own data without needing to fetch parent documents. The `UserSubscription` and `UserPreference` entities also include a `userId` field in their document schemas, which, while not strictly necessary for path-based authorization, adds an explicit data invariant and aids in data consistency and easier client-side querying.\n\n**QAPs (Rules are not Filters):**\n*   **Public Data:** `streaming_services` and `subscription_plans` are structured as top-level collections. This allows for efficient `list` queries (Collection Group queries are not even needed here) as all documents within these collections share the same security posture (public read-only). For example, to list all streaming services, an application can simply query `/streaming_services`, and the rules will grant access to all documents without filtering. Similarly for `/subscription_plans`.\n*   **Private User Data:** For user-owned data like `user_subscriptions` and `user_preferences`, these are implemented as subcollections under `/users/{userId}/`. This path structure inherently filters the data by `userId`. When a user requests their subscriptions (e.g., `db.collection('users').doc(request.auth.uid).collection('user_subscriptions').get()`), the `request.auth.uid` is used in the path itself, ensuring that the query only attempts to fetch documents belonging to the authenticated user. The security rules will then simply verify `request.auth.uid == userId` for the specific path, fulfilling the QAP principle.\n\n**Structural Segregation:** Data with different security requirements is segregated into distinct collections or subcollections. Publicly browsable information (`streaming_services`, `subscription_plans`) is kept separate from private user data (`users`, `user_subscriptions`, `user_preferences`). This simplifies security rules, as each collection/subcollection can have a uniform set of access permissions.\n\n**Access Modeling:** Path-based ownership (`/users/{userId}/...`) is consistently applied for all user-specific and user-owned data. Collaborative data is not explicitly in this schema, but if it were, the membership map pattern would be used and denormalized. Global roles, if needed, would use dedicated collections (e.g., `/roles_admin/{uid}`).\n\n**Data Clarity and Predictability:** Semantic naming (`userId`, `serviceId`, `planId`) and descriptive wildcards are used throughout. The 1:1 `UserPreference` entity is stored as a fixed-document subcollection (`/users/{userId}/user_preferences/profile`) for predictable access."
  }
}