{
  "entities": {
    "UserProfile": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserProfile",
      "type": "object",
      "description": "Represents a user's profile within the StreamShare application, linked to an external authentication system. Contains personal details and preferences for subscription recommendations.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the UserProfile entity."
        },
        "externalAuthId": {
          "type": "string",
          "description": "Unique identifier from the external authentication system (e.g., Firebase UID, Google ID) to link the user's authentication credentials to their application profile."
        },
        "email": {
          "type": "string",
          "description": "The user's email address.",
          "format": "email"
        },
        "firstName": {
          "type": "string",
          "description": "The first name of the user."
        },
        "lastName": {
          "type": "string",
          "description": "The last name of the user."
        },
        "preferredGenres": {
          "type": "array",
          "description": "A list of preferred content genres for subscription recommendations.",
          "items": {
            "type": "string"
          }
        },
        "preferredServices": {
          "type": "array",
          "description": "References to StreamingService IDs that the user prefers or is interested in. (Relationship: StreamingService N:N UserProfile)",
          "items": {
            "type": "string"
          }
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the user profile was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the user profile was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "externalAuthId",
        "email",
        "createdAt",
        "updatedAt"
      ]
    },
    "StreamingService": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StreamingService",
      "type": "object",
      "description": "Represents a streaming service provider like Netflix, Disney+, or HBO Max.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the StreamingService entity."
        },
        "name": {
          "type": "string",
          "description": "The official name of the streaming service (e.g., 'Netflix', 'Disney+')."
        },
        "description": {
          "type": "string",
          "description": "A brief description of the streaming service."
        },
        "logoUrl": {
          "type": "string",
          "description": "URL to the official logo of the streaming service.",
          "format": "uri"
        },
        "websiteUrl": {
          "type": "string",
          "description": "Official website URL for the streaming service.",
          "format": "uri"
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the streaming service record was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the streaming service record was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "name",
        "description",
        "logoUrl",
        "websiteUrl",
        "createdAt",
        "updatedAt"
      ]
    },
    "SubscriptionPlan": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SubscriptionPlan",
      "type": "object",
      "description": "Defines a specific subscription plan offered by a streaming service.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the SubscriptionPlan entity."
        },
        "serviceId": {
          "type": "string",
          "description": "Reference to the StreamingService offering this plan. (Relationship: StreamingService 1:N SubscriptionPlan)"
        },
        "name": {
          "type": "string",
          "description": "The name of the subscription plan (e.g., 'Basic', 'Standard', 'Premium')."
        },
        "description": {
          "type": "string",
          "description": "A detailed description of what the plan offers."
        },
        "price": {
          "type": "number",
          "description": "The monthly or annual price of the subscription plan."
        },
        "currency": {
          "type": "string",
          "description": "The currency of the subscription price (e.g., 'USD', 'BRL')."
        },
        "resolution": {
          "type": "string",
          "description": "The maximum video resolution offered by the plan (e.g., 'SD', 'HD', '4K UHD')."
        },
        "maxScreens": {
          "type": "number",
          "description": "The maximum number of simultaneous screens allowed with this plan."
        },
        "features": {
          "type": "array",
          "description": "A list of key features included in the plan (e.g., 'Downloadable Content', 'Ad-Free').",
          "items": {
            "type": "string"
          }
        },
        "isActive": {
          "type": "boolean",
          "description": "Indicates whether this subscription plan is currently available for purchase."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the subscription plan record was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the subscription plan record was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "serviceId",
        "name",
        "description",
        "price",
        "currency",
        "resolution",
        "maxScreens",
        "isActive",
        "createdAt",
        "updatedAt"
      ]
    },
    "UserSubscription": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserSubscription",
      "type": "object",
      "description": "Represents a specific subscription that a user has purchased, linking a user to a subscription plan.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the UserSubscription entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the UserProfile who owns this subscription. (Relationship: UserProfile 1:N UserSubscription)"
        },
        "planId": {
          "type": "string",
          "description": "Reference to the SubscriptionPlan that the user is subscribed to. (Relationship: SubscriptionPlan 1:N UserSubscription)"
        },
        "startDate": {
          "type": "string",
          "description": "The date when the subscription became active.",
          "format": "date-time"
        },
        "endDate": {
          "type": "string",
          "description": "The date when the subscription is scheduled to end or did end. Null if ongoing with no set end date.",
          "format": "date-time"
        },
        "status": {
          "type": "string",
          "description": "The current status of the user's subscription (e.g., 'active', 'cancelled', 'expired', 'pending')."
        },
        "autoRenew": {
          "type": "boolean",
          "description": "Indicates whether the subscription is set to automatically renew."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the user subscription record was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the user subscription record was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "planId",
        "startDate",
        "status",
        "autoRenew",
        "createdAt",
        "updatedAt"
      ]
    },
    "Payment": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Payment",
      "type": "object",
      "description": "Records details of a payment made by a user for a subscription.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Payment entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the UserProfile who made the payment. (Relationship: UserProfile 1:N Payment)"
        },
        "userSubscriptionId": {
          "type": "string",
          "description": "Reference to the UserSubscription this payment is for. (Relationship: UserSubscription 1:N Payment)"
        },
        "amount": {
          "type": "number",
          "description": "The amount paid for the subscription."
        },
        "currency": {
          "type": "string",
          "description": "The currency of the payment (e.g., 'USD', 'BRL')."
        },
        "paymentDate": {
          "type": "string",
          "description": "The date and time the payment was successfully processed.",
          "format": "date-time"
        },
        "status": {
          "type": "string",
          "description": "The status of the payment (e.g., 'completed', 'failed', 'refunded', 'pending')."
        },
        "paymentGatewayTransactionId": {
          "type": "string",
          "description": "The transaction ID provided by the external payment gateway for reconciliation."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the payment record was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the payment record was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "userSubscriptionId",
        "amount",
        "currency",
        "paymentDate",
        "status",
        "paymentGatewayTransactionId",
        "createdAt",
        "updatedAt"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "UserProfile",
          "schema": {
            "$ref": "#/backend/entities/UserProfile"
          },
          "description": "Stores individual user profiles. The document ID `{userId}` directly corresponds to the Firebase Authentication UID (`request.auth.uid`) for that user. The 'id' field within the document also stores this UID, ensuring path-based ownership for simple and robust security rules."
        }
      },
      {
        "path": "/streaming_services/{serviceId}",
        "definition": {
          "entityName": "StreamingService",
          "schema": {
            "$ref": "#/backend/entities/StreamingService"
          },
          "description": "Contains global, publicly accessible information about each streaming service. These documents are read-only for all users and managed by administrators. The `{serviceId}` wildcard is the unique identifier for each service."
        }
      },
      {
        "path": "/subscription_plans/{planId}",
        "definition": {
          "entityName": "SubscriptionPlan",
          "schema": {
            "$ref": "#/backend/entities/SubscriptionPlan"
          },
          "description": "Stores details about specific subscription plans offered by various streaming services. This is a top-level collection to facilitate global listing and querying of plans (QAP compliance). Each document includes a 'serviceId' field to link it to its parent StreamingService. Publicly readable for all users. The `{planId}` wildcard is the unique identifier for each plan."
        }
      },
      {
        "path": "/users/{userId}/user_subscriptions/{userSubscriptionId}",
        "definition": {
          "entityName": "UserSubscription",
          "schema": {
            "$ref": "#/backend/entities/UserSubscription"
          },
          "description": "Stores details of a user's active or past subscriptions. This is a subcollection under a specific user's profile. Includes denormalized 'userId' field matching the `{userId}` path wildcard for authorization independence and secure QAPs. Only the owning user can read/write their subscriptions. The `{userSubscriptionId}` wildcard is the unique identifier for each user subscription."
        }
      },
      {
        "path": "/users/{userId}/payments/{paymentId}",
        "definition": {
          "entityName": "Payment",
          "schema": {
            "$ref": "#/backend/entities/Payment"
          },
          "description": "Records individual payment transactions made by a user. This is a subcollection under a specific user's profile. Includes denormalized 'userId' field matching the `{userId}` path wildcard for authorization independence and secure QAPs. Only the owning user can read/write their payment records. The `{paymentId}` wildcard is the unique identifier for each payment."
        }
      }
    ],
    "reasoning": "The recommended Firestore structure is designed with a strong emphasis on Authorization Independence, Structural Segregation, and clear Access Modeling, ensuring robust security rules and efficient querying as per the core design principles. The structure separates global, public data from private, user-specific data to provide homogeneous security postures for collections.\n\n**Authorization Independence (CRITICAL):**\n1.  **User-Owned Data (`/users/{userId}/...`):** All user-specific data, such as `UserProfile`, `UserSubscription`, and `Payment`, are stored under a path segmented by the user's Firebase Authentication UID (`/users/{userId}`). Crucially, the documents within these subcollections (e.g., `UserSubscription`, `Payment`) include a denormalized `userId` field. This `userId` field in the document **must** match the `{userId}` wildcard in the path, as well as `request.auth.uid`. This design completely eliminates the need for `get()` calls in security rules to check parent ownership, thereby preventing atomic operation failures and simplifying rule logic. For example, to read a `UserSubscription`, the rule simply checks `request.auth.uid == resource.data.userId && request.auth.uid == userId` (where `userId` is the path wildcard), which is efficient and independent.\n2.  **Global Data (`/streaming_services`, `/subscription_plans`):** These collections contain publicly readable data. Since their access doesn't depend on a parent document's attributes or user-specific roles (other than potentially admin write access, which is usually handled by `request.auth.uid` directly or a top-level roles collection), no denormalization for authorization is needed. They are inherently authorization-independent for reads.\n\n**QAPs (Rules are not Filters):**\n1.  **Public Collections (`/streaming_services`, `/subscription_plans`):** These collections are intended for public read. Any user can `list` and `get` documents from these collections. The security rules for these collections will simply `allow read: if true;`, which is a query-safe operation as all data is accessible. Users can then apply client-side filtering (e.g., filter `SubscriptionPlans` by `serviceId`) after fetching, or use server-side queries on fields like `serviceId`, which are secure due to the public nature of the data.\n2.  **Private User Collections (`/users/{userId}/user_subscriptions`, `/users/{userId}/payments`):** By structuring these as subcollections under `/users/{userId}`, security rules can enforce that a user can only `list` or `get` documents within their own `/users/{request.auth.uid}/...` path. The rule would check `allow read: if request.auth.uid == userId;` (for the path wildcard) and `request.auth.uid == resource.data.userId` (for the denormalized field). This ensures that `list` operations implicitly filter by the authenticated user, satisfying the QAPs principle by making unauthorized reads impossible rather than relying on rules to filter results after the fact. The `UserProfile` itself, located at `/users/{userId}`, is also exclusively owned and accessible by `request.auth.uid`."
  }
}